<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>Outlook ì¼€ì´ìŠ¤ íƒ€ì„ë¼ì¸ ë¶„ì„ê¸° (emailjs-mime-parser Â· EML ì „ìš© Â· í…ìŠ¤íŠ¸ ë·°ì–´)</title>

  <style>
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",sans-serif;
      background:#f3f4f6;
      color:#111;
    }
    header{
      position:sticky;top:0;z-index:10;
      background:linear-gradient(90deg,#1e40af,#0f766e);
      color:#fff;padding:12px 20px;
      display:flex;justify-content:space-between;align-items:center;gap:12px;
      box-shadow:0 2px 6px rgba(0,0,0,.2);
    }
    .title{font-size:18px;font-weight:600}
    .subtitle{font-size:12px;opacity:.9}
    .file-box{
      display:flex;align-items:center;gap:8px;
      background:rgba(255,255,255,.2);padding:6px 12px;
      border-radius:999px;font-size:12px
    }
    main{display:flex;gap:16px;padding:16px}
    .sidebar{
      width:260px;background:#fff;border-radius:12px;padding:12px;
      height:calc(100vh - 70px);overflow:auto;
      box-shadow:0 2px 6px rgba(0,0,0,.08);font-size:12px;
    }
    .content{flex:1;height:calc(100vh - 70px);overflow:auto}
    .section-title{font-weight:600;font-size:13px;margin:8px 0}
    .small-btn{
      padding:6px 8px;border-radius:8px;border:1px solid #d1d5db;font-size:12px;
      background:#fff;cursor:pointer;width:100%
    }
    .small-btn:hover{background:#f3f4f6}
    .case-item{padding:6px;border-radius:8px;cursor:pointer;margin-bottom:4px}
    .case-item:hover{background:#e5e7eb}
    .case-item.active{background:#0f766e;color:#fff}
    #dropZone{
      border:2px dashed #9ca3af;background:#fff;padding:30px;
      border-radius:12px;text-align:center;font-size:13px;color:#6b7280;margin-bottom:12px
    }
    #dropZone.dragover{border-color:#2563eb;background:#eff6ff;color:#1d4ed8}
    .controls-row{display:flex;gap:8px;margin-bottom:10px}
    .search-input{
      flex:1;padding:6px 12px;border-radius:999px;border:1px solid #d1d5db;font-size:13px
    }
    .toggle-group{display:flex;gap:6px;margin:10px 0}
    .toggle-btn{
      flex:1;padding:6px;border-radius:999px;border:1px solid #d1d5db;background:#fff;font-size:12px
    }
    .toggle-btn.active{background:#1e40af;color:#fff;border-color:#1e40af}
    .thread-item{padding:6px;border-radius:8px;margin-bottom:4px;cursor:pointer}
    .thread-item:hover{background:#f3f4f6}
    .thread-item.active{background:#1d4ed8;color:#fff}
    .summary-card{
      background:#fefce8;border:1px solid #facc15;padding:10px;border-radius:12px;
      font-size:12px;white-space:pre-wrap;margin-bottom:12px
    }
    .mail-card{
      background:#fff;border-radius:12px;padding:12px;margin-bottom:12px;
      box-shadow:0 1px 4px rgba(0,0,0,.08);border-left:3px solid #e5e7eb;font-size:12px
    }
    .mail-header{display:flex;justify-content:space-between;margin-bottom:6px;gap:8px}
    .mail-subject{font-weight:600;margin-bottom:4px}
    .mail-meta{font-size:12px;color:#6b7280}
    .mail-date{font-size:12px;color:#374151;white-space:nowrap}
    .clickable{color:#2563eb;cursor:pointer;text-decoration:underline dotted;font-size:12px}
    .mail-body-preview{white-space:pre-wrap;margin-top:4px;color:#374151}
    .mail-body-full{display:none;border-top:1px dashed #ddd;padding-top:6px;margin-top:6px;white-space:pre-wrap}
    .pill{display:inline-block;padding:2px 6px;border-radius:999px;background:#f3f4f6;margin-right:4px;font-size:11px}
    @media(max-width:900px){
      main{flex-direction:column}
      .sidebar{width:100%;height:auto}
      .content{height:auto}
    }
  </style>
</head>
<body>

<header>
  <div>
    <div class="title">Outlook ì¼€ì´ìŠ¤ íƒ€ì„ë¼ì¸ ë¶„ì„ê¸°</div>
    <div class="subtitle">EML ì „ìš© Â· emailjs-mime-parser ê¸°ë°˜ Â· GitHub JSON ì €ì¥ Â· í…ìŠ¤íŠ¸ ë·°ì–´</div>
  </div>
  <div class="file-box">
    <span>ğŸ“ EML íŒŒì¼ ì„ íƒ</span>
    <input id="fileInput" type="file" multiple accept=".eml" />
  </div>
</header>

<main>
  <!-- ì‚¬ì´ë“œë°” -->
  <aside class="sidebar">
    <div class="section-title">GitHub ì„¤ì •</div>
    <label style="font-size:12px">ê°œì¸ ì•¡ì„¸ìŠ¤ í† í°</label>
    <input id="ghToken" type="password" placeholder="github_pat_..." style="width:100%;padding:6px;border:1px solid #ddd;border-radius:6px">
    <button id="btnSaveGh" class="small-btn" style="margin-top:6px">í† í° ì €ì¥</button>
    <button id="btnLoadCases" class="small-btn" style="margin-top:6px">ì¼€ì´ìŠ¤ ëª©ë¡ ë¶ˆëŸ¬ì˜¤ê¸°</button>

    <hr style="margin:16px 0">

    <div class="section-title">ì¼€ì´ìŠ¤ ê´€ë¦¬</div>
    <button id="btnAddCase" class="small-btn">â• ìƒˆ ì¼€ì´ìŠ¤</button>
    <div id="caseList" style="margin-top:10px"></div>

    <hr style="margin:16px 0">

    <div id="statsBox" style="font-size:12px;line-height:1.5;color:#444">
      GitHub í† í° ì…ë ¥ í›„ ì¼€ì´ìŠ¤ ëª©ë¡ì„ ë¶ˆëŸ¬ì˜¤ì„¸ìš”.
    </div>

    <div class="section-title">ë³´ê¸° ëª¨ë“œ</div>
    <div class="toggle-group">
      <button id="btnTimeline" class="toggle-btn active">íƒ€ì„ë¼ì¸</button>
      <button id="btnThread" class="toggle-btn">ìŠ¤ë ˆë“œ</button>
    </div>

    <div class="section-title">ìŠ¤ë ˆë“œ ëª©ë¡</div>
    <div id="threadList"></div>
  </aside>

  <!-- ë³¸ë¬¸ -->
  <section class="content">

    <div id="dropZone">
      ì´ê³³ì— <b>.eml</b> íŒŒì¼ì„ ë“œë˜ê·¸í•´ì„œ ë†“ìœ¼ì„¸ìš”<br>
      <span style="font-size:11px;color:#aaa">ì„ íƒëœ ì¼€ì´ìŠ¤ì— ìë™ ì €ì¥ë©ë‹ˆë‹¤ (MSGëŠ” ì‚¬ì „ì— EMLë¡œ ë³€í™˜ í•„ìš”)</span>
    </div>

    <div class="controls-row">
      <input id="searchInput" class="search-input" placeholder="ì œëª© / ë³¸ë¬¸ / ë³´ë‚¸ì‚¬ëŒ / ë°›ëŠ”ì‚¬ëŒ ê²€ìƒ‰">
      <button id="btnClearSearch" class="small-btn">ì´ˆê¸°í™”</button>
    </div>

    <div id="viewInfo" style="font-size:12px;color:#444;margin-bottom:6px"></div>

    <div id="summaryContainer"></div>
    <div id="mailContainer"></div>
  </section>
</main>

<!-- ë©”ì¸ ë¡œì§ -->
<script type="module">
  import parseMime from "https://esm.run/emailjs-mime-parser@2.0.6";

  /* --------------------------
     GitHub ì €ì¥ì†Œ ê¸°ë³¸ ì„¤ì •
  -------------------------- */
  let github = {
    user: "etech-symantec",
    repo: "case",
    branch: "main",
    token: ""
  };

  function ghHeaders(){
    const h = {"Accept":"application/vnd.github+json"};
    if(github.token) h["Authorization"] = "Bearer " + github.token;
    return h;
  }
  function ghUrl(path){
    return `https://api.github.com/repos/${github.user}/${github.repo}/contents/${path}`;
  }

  function b64e(str){return btoa(unescape(encodeURIComponent(str)));}
  function b64d(b){return decodeURIComponent(escape(atob(b)));}

  async function ghGet(path){
    const url = ghUrl(path) + "?ref=" + github.branch;
    const res = await fetch(url,{headers:ghHeaders()});
    if(res.status===404) return null;
    if(!res.ok) throw new Error("GET ì‹¤íŒ¨ "+res.status);
    const data = await res.json();
    return JSON.parse(b64d(data.content));
  }

  async function ghPut(path,obj,msg){
    if(!github.token){alert("GitHub ì €ì¥ì—ëŠ” í† í°ì´ í•„ìš”í•©ë‹ˆë‹¤.");return;}
    const url = ghUrl(path);

    let sha=null;
    const res0 = await fetch(url,{headers:ghHeaders()});
    if(res0.status===200){
      const j=await res0.json();
      sha=j.sha;
    }

    const body={
      message: msg || "update",
      content: b64e(JSON.stringify(obj,null,2)),
      branch: github.branch
    };
    if(sha) body.sha=sha;

    const res = await fetch(url,{
      method:"PUT",
      headers:{...ghHeaders(),"Content-Type":"application/json"},
      body:JSON.stringify(body)
    });
    if(!res.ok){
      const t=await res.text();
      throw new Error("PUT ì‹¤íŒ¨ "+res.status+" "+t);
    }
  }

  /* --------------------------
     ì¼€ì´ìŠ¤ ë°ì´í„° êµ¬ì¡°
  -------------------------- */
  let casesMeta=[];    // [{id,name}]
  let caseData={};     // id â†’ {id,name,emails}
  let currentCaseId=null;

  let allEmails=[];
  let threads=[];
  let currentView="timeline";
  let currentThreadKey=null;

  /* --------------------------
     ìœ í‹¸ / í¬ë§·í„°
  -------------------------- */
  function normalizeSubject(s){
    if(!s) return "(no-subject)";
    return s
      .toLowerCase()
      .replace(/^\s*(re|fw|fwd|ë‹µì¥|ì „ë‹¬|íšŒì‹ )\s*:\s*/gi,"")
      .replace(/^\[.*?\]\s*/,"")
      .trim() || "(no-subject)";
  }

  function fmtDate(d){
    if(!(d instanceof Date) || isNaN(d)) return "ë‚ ì§œ ì—†ìŒ";
    return `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,"0")}-${String(d.getDate()).padStart(2,"0")} ${String(d.getHours()).padStart(2,"0")}:${String(d.getMinutes()).padStart(2,"0")}`;
  }

  function esc(s){
    return String(s||"").replace(/[&<>]/g,m=>({"&":"&amp;","<":"&lt;",">":"&gt;"}[m]));
  }

  function makePreview(body){
    if(!body) return "(ë³¸ë¬¸ ì—†ìŒ)";
    const first = String(body).split(/\r?\n/).map(l=>l.trim()).filter(Boolean).slice(0,3).join(" ");
    return first.length>260 ? first.slice(0,260)+"â€¦" : first;
  }

  /* --------------------------
     MIME ë””ì½”ë”© ìœ í‹¸ (í…ìŠ¤íŠ¸ ì „ìš©)
  -------------------------- */
  function decodeQuotedPrintable(str){
    if(!str) return "";
    // soft line break (= + CRLF) ì œê±°
    str = str.replace(/=\r?\n/g, "");
    // =XX â†’ í•´ë‹¹ ë¬¸ì
    return str.replace(/=([0-9A-Fa-f]{2})/g, (m, hex) => {
      try{
        return String.fromCharCode(parseInt(hex,16));
      }catch(e){
        return m;
      }
    });
  }

  function decodeBase64ToUtf8(str){
    if(!str) return "";
    try{
      const cleaned = str.replace(/\s+/g,"");
      return decodeURIComponent(escape(atob(cleaned)));
    }catch(e){
      try{
        return atob(str.replace(/\s+/g,""));
      }catch(e2){
        return str;
      }
    }
  }

  function cleanupPlainText(body){
    if(!body) return "";
    let out = body;
    // ì•ë’¤ ê³µë°± ì •ë¦¬
    out = out.replace(/\r\n/g,"\n");
    // MIME ê²½ê³„ì„ , Content-* í—¤ë” ê°™ì€ ë¼ì¸ ì œê±°
    out = out.split("\n").filter(line=>{
      const trimmed = line.trim();
      if(!trimmed) return true; // ë¹ˆ ì¤„ì€ ìœ ì§€
      if(/^--[0-9A-Za-z'()+_,-\.\/:=?]{10,}$/.test(trimmed)) return false; // boundary
      if(/^content-(type|transfer-encoding|id|disposition)/i.test(trimmed)) return false;
      if(/^mime-version:/i.test(trimmed)) return false;
      return true;
    }).join("\n");

    // ì—°ì† ë¹ˆ ì¤„ 3ê°œ ì´ìƒ â†’ 2ê°œë¡œ ì¶•ì†Œ
    out = out.replace(/\n{3,}/g,"\n\n");

    return out.trim();
  }

  /* --------------------------
     emailjs-mime-parser + ìˆ˜ë™ MIME íŒŒì‹± ê¸°ë°˜ EML íŒŒì„œ
     â†’ "ì‹¤ì œ ë©”ì¼ ë‚´ìš©" í…ìŠ¤íŠ¸ë§Œ ì¶”ì¶œ
  -------------------------- */
  function parseEml(rawEml) {
    // ===== ê³µí†µ ìœ í‹¸ =====
    function normalizeNewlines(str) {
      return str.replace(/\r\n/g, "\n").replace(/\r/g, "\n");
    }
  
    function mapCharset(cs) {
      if (!cs) return "utf-8";
      cs = cs.toLowerCase().trim();
      if (cs === "ks_c_5601-1987" || cs === "ks_c_5601" || cs === "cp949") {
        return "euc-kr";
      }
      return cs;
    }
  
    function decodeBytesToString(bytes, charset) {
      charset = mapCharset(charset);
      try {
        return new TextDecoder(charset).decode(bytes);
      } catch (e) {
        // ì§€ì› ì•ˆ ë˜ëŠ” charsetì´ë©´ UTF-8ë¡œë¼ë„ ë³µêµ¬
        try {
          return new TextDecoder("utf-8").decode(bytes);
        } catch (e2) {
          // ì§„ì§œ ì•ˆ ë˜ë©´ ëŒ€ì¶© ASCIIë¡œ
          return String.fromCharCode.apply(null, Array.from(bytes));
        }
      }
    }
  
    // ===== í—¤ë” íŒŒì‹± (folded header í¬í•¨) =====
    function parseHeaders(headerText) {
      const headers = {};
      const lines = headerText.split("\n");
      let currentName = null;
      let currentValue = "";
  
      for (let line of lines) {
        if (/^\s/.test(line) && currentName) {
          // ì´ì–´ì§€ëŠ” ì¤„
          currentValue += " " + line.trim();
        } else {
          if (currentName) {
            headers[currentName.toLowerCase()] = currentValue.trim();
          }
          const idx = line.indexOf(":");
          if (idx !== -1) {
            currentName = line.substring(0, idx).trim();
            currentValue = line.substring(idx + 1).trim();
          } else {
            currentName = null;
            currentValue = "";
          }
        }
      }
      if (currentName) {
        headers[currentName.toLowerCase()] = currentValue.trim();
      }
      return headers;
    }
  
    // ===== Content-Type íŒŒì‹± (mimeType / charset / boundary) =====
    function parseContentType(value) {
      let mimeType = "text/plain";
      let charset = "utf-8";
      let boundary = null;
  
      if (!value) {
        return { mimeType, charset, boundary };
      }
  
      const raw = value;
      const parts = raw.split(";");
      if (parts[0]) {
        mimeType = parts[0].trim().toLowerCase();
      }
  
      // charsetì€ ì—¬ëŸ¬ ë²ˆ ë‚˜ì˜¬ ìˆ˜ ìˆì–´, ë§ˆì§€ë§‰ ê²ƒì„ ìš°ì„ 
      const charsetMatches = raw.match(/charset\s*=\s*"?([^";]+)/gi);
      if (charsetMatches && charsetMatches.length > 0) {
        const last = charsetMatches[charsetMatches.length - 1];
        const m = /charset\s*=\s*"?([^";]+)/i.exec(last);
        if (m && m[1]) {
          charset = m[1].trim();
        }
      }
  
      const boundaryMatch = raw.match(/boundary\s*=\s*"?([^";]+)/i);
      if (boundaryMatch && boundaryMatch[1]) {
        boundary = boundaryMatch[1].trim();
      }
  
      return {
        mimeType: mimeType || "text/plain",
        charset: charset || "utf-8",
        boundary,
      };
    }
  
    // ===== Content-Transfer-Encoding ë””ì½”ë”© =====
    function decodeBase64(body, charset) {
      const cleaned = body.replace(/\s+/g, "");
      if (!cleaned) return "";
      let binary;
      try {
        binary = atob(cleaned);
      } catch (e) {
        return body; // ì‹¤íŒ¨í•˜ë©´ ì›ë¬¸ ë°˜í™˜
      }
      const len = binary.length;
      const bytes = new Uint8Array(len);
      for (let i = 0; i < len; i++) {
        bytes[i] = binary.charCodeAt(i) & 0xff;
      }
      return decodeBytesToString(bytes, charset);
    }
  
    function decodeQuotedPrintable(body, charset) {
      // soft line breaks ì œê±°
      let str = body.replace(/=\n/g, "").replace(/=\r\n/g, "");
      const bytes = [];
      for (let i = 0; i < str.length; i++) {
        const ch = str[i];
        if (ch === "=" && i + 2 < str.length && /[0-9A-Fa-f]{2}/.test(str.substr(i + 1, 2))) {
          const hex = str.substr(i + 1, 2);
          bytes.push(parseInt(hex, 16));
          i += 2;
        } else {
          bytes.push(ch.charCodeAt(0) & 0xff);
        }
      }
      return decodeBytesToString(new Uint8Array(bytes), charset);
    }
  
    function decodeTransfer(body, cte, charset, mimeType) {
      cte = (cte || "").toLowerCase();
      let decoded;
  
      if (cte === "base64") {
        decoded = decodeBase64(body, charset);
      } else if (cte === "quoted-printable") {
        decoded = decodeQuotedPrintable(body, charset);
      } else {
        // 7bit / 8bit / binary ë“± : ì´ë¯¸ ASCII ìœ„ì£¼ë¼ê³  ê°€ì •
        const bytes = new Uint8Array(body.split("").map(c => c.charCodeAt(0) & 0xff));
        decoded = decodeBytesToString(bytes, charset);
      }
  
      return decoded;
    }
  
    // ===== text/html â†’ ìˆœìˆ˜ í…ìŠ¤íŠ¸ =====
    function htmlToText(html) {
      if (!html) return "";
      // Word/Office ì „ìš© XML, ìŠ¤íƒ€ì¼, ì½”ë©˜íŠ¸ ì œê±° (ëŒ€ë¶€ë¶„ ë¸Œë¼ìš°ì €ì—ì„œ ìë™ ë¬´ì‹œë˜ì§€ë§Œ í•œë²ˆ ë”)
      html = html
        .replace(/<style[\s\S]*?<\/style>/gi, "")
        .replace(/<script[\s\S]*?<\/script>/gi, "")
        .replace(/<xml[\s\S]*?<\/xml>/gi, "")
        .replace(/<!--[\s\S]*?-->/g, "");
  
      const div = document.createElement("div");
      div.innerHTML = html;
      let text = div.innerText || div.textContent || "";
  
      // ì¤„ë°”ê¿ˆ ì •ë¦¬
      text = text
        .replace(/\r/g, "\n")
        .replace(/\n[ \t]+\n/g, "\n")
        .replace(/\n{3,}/g, "\n\n")
        .trim();
  
      return text;
    }
  
    // ===== MIME ì¸ì½”ë”© ëœ í—¤ë” (=?charset?B?...?=) ë””ì½”ë”© =====
    function decodeMimeHeader(value) {
      if (!value) return "";
      const regex = /=\?([^?]+)\?([bqBQ])\?([^?]*)\?=/g;
  
      return value.replace(regex, (match, charset, enc, text) => {
        charset = charset || "utf-8";
        enc = (enc || "B").toUpperCase();
  
        if (enc === "B") {
          // Base64
          const cleaned = text.replace(/\s+/g, "");
          let binary;
          try {
            binary = atob(cleaned);
          } catch (e) {
            return text;
          }
          const bytes = new Uint8Array(binary.length);
          for (let i = 0; i < binary.length; i++) {
            bytes[i] = binary.charCodeAt(i) & 0xff;
          }
          return decodeBytesToString(bytes, charset);
        } else {
          // Q-encoding
          let s = text.replace(/_/g, " ");
          const bytes = [];
          for (let i = 0; i < s.length; i++) {
            const ch = s[i];
            if (ch === "=" && i + 2 < s.length && /[0-9A-Fa-f]{2}/.test(s.substr(i + 1, 2))) {
              const hex = s.substr(i + 1, 2);
              bytes.push(parseInt(hex, 16));
              i += 2;
            } else {
              bytes.push(s.charCodeAt(i) & 0xff);
            }
          }
          return decodeBytesToString(new Uint8Array(bytes), charset);
        }
      });
    }
  
    // ===== ë‹¨ì¼ íŒŒíŠ¸ ë””ì½”ë”© =====
    function decodeSinglePart(headers, bodyText, defaultMime, defaultCharset) {
      const ctHeader = headers["content-type"] || "";
      const { mimeType, charset } = parseContentType(ctHeader || defaultMime || "text/plain");
      const effectiveCharset = charset || defaultCharset || "utf-8";
      const cte = headers["content-transfer-encoding"] || "";
  
      const decoded = decodeTransfer(bodyText, cte, effectiveCharset, mimeType);
      let text = decoded;
      let rawHtml = null;
  
      if (mimeType.indexOf("text/html") === 0) {
        rawHtml = decoded;
        text = htmlToText(decoded);
      }
  
      return {
        headers,
        mimeType,
        charset: mapCharset(effectiveCharset),
        text,
        rawHtml,
        raw: decoded,
        multipart: false,
        children: [],
      };
  }

  // ===== multipart íŒŒíŠ¸ íŒŒì‹± =====
  function parseMultipart(bodyText, boundary, parentCharset) {
    const parts = [];
    if (!boundary) return parts;

    const boundaryText = "--" + boundary;
    const lines = bodyText.split("\n");
    let currentPartLines = [];
    let inPart = false;

    for (let line of lines) {
      if (line.startsWith(boundaryText)) {
        if (inPart && currentPartLines.length > 0) {
          parts.push(currentPartLines.join("\n"));
          currentPartLines = [];
        }
        if (line.startsWith(boundaryText + "--")) {
          inPart = false;
          break;
        } else {
          inPart = true;
        }
      } else if (inPart) {
        currentPartLines.push(line);
      }
    }
    if (inPart && currentPartLines.length > 0) {
      parts.push(currentPartLines.join("\n"));
    }

    // ê° partë¥¼ ë‹¤ì‹œ í—¤ë”/ë°”ë””ë¡œ ë‚˜ëˆ  ì¬ê·€ ì²˜ë¦¬
    const nodes = [];
    for (let rawPart of parts) {
      const splitIndex = rawPart.indexOf("\n\n");
      let headerText = "";
      let body = "";
      if (splitIndex === -1) {
        headerText = rawPart;
        body = "";
      } else {
        headerText = rawPart.substring(0, splitIndex);
        body = rawPart.substring(splitIndex + 2);
      }
      const headers = parseHeaders(headerText);
      const ctHeader = headers["content-type"] || "";
      const { mimeType, charset, boundary: childBoundary } = parseContentType(ctHeader || "");
      const effectiveCharset = charset || parentCharset || "utf-8";

      if (mimeType && mimeType.startsWith("multipart/") && childBoundary) {
        const children = parseMultipart(body, childBoundary, effectiveCharset);
        nodes.push({
          headers,
          mimeType,
          charset: mapCharset(effectiveCharset),
          multipart: true,
          children,
          text: "",
          rawHtml: null,
        });
      } else {
        nodes.push(decodeSinglePart(headers, body, mimeType, effectiveCharset));
      }
    }

    return nodes;
  }

  // ===== ì§€ë‚œ ë©”ì¼ ë‚´ìš© ì œê±° =====
  function stripReply(body){
    if(!body) return body;
  
    const patterns = [
      /^-----Original Message-----/i,
      /^----- Forwarded by/i,
      /^On .* wrote:$/i,
      /^ë³´ë‚¸ ì‚¬ëŒ:/i,
      /^ë°›ëŠ” ì‚¬ëŒ:/i,
      /^ì°¸ì¡°:/i,
      /^ë°œì‹ :/i
    ];
  
    const lines = body.split(/\r?\n/);
    let clean = [];
  
    for(let i=0;i<lines.length;i++){
      let stop = patterns.some(p => p.test(lines[i]));
      if(stop) break;      // ì—¬ê¸°ì„œë¶€í„° ì•„ë˜ëŠ” ì œê±°
      clean.push(lines[i]);
    }
    return clean.join("\n").trim();
  }
  
  // parseEml ë§ˆì§€ë§‰ return ì§ì „:
  body = stripReply(body);


  // ===== ì‹¤ì œ EML íŒŒì‹± ì‹œì‘ =====
  if (!rawEml) {
    return {
      headers: {},
      subject: "",
      from: "",
      to: "",
      date: "",
      body: "",
      rawHtml: "",
      contentType: "text/plain",
    };
  }

  const normalized = normalizeNewlines(rawEml);
  const firstBlank = normalized.indexOf("\n\n");
  let headerText, bodyText;

  if (firstBlank === -1) {
    headerText = normalized;
    bodyText = "";
  } else {
    headerText = normalized.substring(0, firstBlank);
    bodyText = normalized.substring(firstBlank + 2);
  }

  const headers = parseHeaders(headerText);
  const rootCtHeader = headers["content-type"] || "";
  const { mimeType: rootMimeType, charset: rootCharset, boundary: rootBoundary } =
    parseContentType(rootCtHeader);

  let body = "";
  let rawHtml = "";

  if (rootMimeType && rootMimeType.startsWith("multipart/") && rootBoundary) {
    // multipart: íŠ¸ë¦¬ êµ¬ì¡°ë¡œ íŒŒì‹± í›„ text/plain ìš°ì„  ì„ íƒ
    const rootNode = {
      headers,
      mimeType: rootMimeType,
      charset: mapCharset(rootCharset || "utf-8"),
      multipart: true,
      children: parseMultipart(bodyText, rootBoundary, rootCharset || "utf-8"),
      text: "",
      rawHtml: null,
    };

    const textPlainParts = [];
    const textHtmlParts = [];

    function walk(node) {
      if (!node) return;
      if (node.multipart && node.children && node.children.length) {
        node.children.forEach(walk);
      } else {
        if (!node.mimeType) return;
        const mt = node.mimeType.toLowerCase();
        if (mt.indexOf("text/plain") === 0) {
          textPlainParts.push(node);
        } else if (mt.indexOf("text/html") === 0) {
          textHtmlParts.push(node);
        }
      }
    }

    walk(rootNode);

    if (textPlainParts.length > 0) {
      // utf-8 / euc-kr ìš°ì„ 
      let chosen =
        textPlainParts.find(p => p.charset === "utf-8" || p.charset === "euc-kr") ||
        textPlainParts[0];
      body = (chosen.text || "").trim();
    } else if (textHtmlParts.length > 0) {
      let chosen =
        textHtmlParts.find(p => p.charset === "utf-8" || p.charset === "euc-kr") ||
        textHtmlParts[0];
      rawHtml = chosen.rawHtml || chosen.raw || "";
      body = htmlToText(rawHtml);
    } else {
      body = "";
      rawHtml = "";
    }

    if (!rawHtml && textHtmlParts.length > 0) {
      const htmlNode =
        textHtmlParts.find(p => p.charset === "utf-8" || p.charset === "euc-kr") ||
        textHtmlParts[0];
      rawHtml = htmlNode.rawHtml || htmlNode.raw || "";
    }
  } else {
    // ë‹¨ì¼ íŒŒíŠ¸
    const part = decodeSinglePart(headers, bodyText, rootMimeType, rootCharset || "utf-8");
    body = (part.text || "").trim();
    rawHtml = part.rawHtml || "";
  }

  const subject = decodeMimeHeader(headers["subject"]);
  const from = decodeMimeHeader(headers["from"]);
  const to = decodeMimeHeader(headers["to"]);
  const date = headers["date"] || "";

  return {
    headers,
    subject,
    from,
    to,
    date,
    body,
    rawHtml,
    contentType: rootMimeType || "text/plain",
  };
}


  /* --------------------------
     íŒŒì¼ ì²˜ë¦¬ + ë“œë˜ê·¸ë“œë
  -------------------------- */
  async function handleFiles(files){
    if(!currentCaseId){
      alert("ë¨¼ì € ì¼€ì´ìŠ¤ë¥¼ ì„ íƒí•˜ê±°ë‚˜ ìƒì„±í•˜ì„¸ìš”.");
      return;
    }

    allEmails = caseData[currentCaseId]?.emails || [];

    let remain = files.length;
    if(!remain) return;

    for(const file of files){
      const name = file.name;
      const ext  = name.split(".").pop().toLowerCase();

      if(ext !== "eml"){
        alert(name + " : ì´ ë²„ì „ì€ .emlë§Œ ì§€ì›í•©ë‹ˆë‹¤. (.msgëŠ” ì‚¬ì „ì— .emlë¡œ ë³€í™˜í•´ì£¼ì„¸ìš”)");
        remain--;
        continue;
      }

      const reader = new FileReader();
      reader.onload = ev => {
        try{
          const raw = ev.target.result;
          const mail = parseEml(raw, name);
          allEmails.push(mail);
        }catch(e){
          console.error("EML íŒŒì‹± ì‹¤íŒ¨:", name, e);
        }finally{
          remain--;
          if(remain===0){
            caseData[currentCaseId].emails = allEmails;
            postProcess();
            ghPut(`cases/${currentCaseId}.json`,caseData[currentCaseId],"update case")
              .catch(err=>alert("GitHub ì €ì¥ ì‹¤íŒ¨: "+err.message));
          }
        }
      };
      reader.readAsText(file,"utf-8");
    }
  }

  /* --------------------------
     í›„ì²˜ë¦¬ / ë Œë”ë§
  -------------------------- */
  function postProcess(){
    if(!allEmails.length){
      document.getElementById("statsBox").textContent = "ë©”ì¼ ì—†ìŒ";
      document.getElementById("threadList").innerHTML = "";
      document.getElementById("mailContainer").innerHTML = "";
      document.getElementById("summaryContainer").innerHTML = "";
      document.getElementById("viewInfo").textContent = "";
      return;
    }

    // ë‚ ì§œ ìˆœ ì •ë ¬
    allEmails.sort((a,b)=>{
      const t1 = (a.dateObj instanceof Date && !isNaN(a.dateObj)) ? a.dateObj.getTime() : 0;
      const t2 = (b.dateObj instanceof Date && !isNaN(b.dateObj)) ? b.dateObj.getTime() : 0;
      return t1 - t2;
    });

    // thread grouping
    const map = new Map();
    allEmails.forEach(m=>{
      const k=m.threadKey || "(no-subject)";
      if(!map.has(k)) map.set(k,{threadKey:k,subject:m.subject,items:[]});
      map.get(k).items.push(m);
    });
    threads=[...map.values()];

    updateStats();
    renderThreads();
    renderView();
  }

  function updateStats(){
    const statsBox = document.getElementById("statsBox");
    statsBox.innerHTML = `ë©”ì¼: <b>${allEmails.length}</b>ê°œ<br>ìŠ¤ë ˆë“œ: <b>${threads.length}</b>ê°œ`;
  }

  function renderThreads(){
    const el = document.getElementById("threadList");
    el.innerHTML = "";
    threads.forEach(t=>{
      const div=document.createElement("div");
      div.className="thread-item"+(t.threadKey===currentThreadKey?" active":"");
      div.textContent=`${t.subject} (${t.items.length})`;
      div.onclick=()=>{
        currentThreadKey=t.threadKey;
        currentView="thread";
        renderView();
        renderThreads();
      };
      el.appendChild(div);
    });
  }

  function renderView(){
    let list=[...allEmails];
    if(currentView==="thread" && currentThreadKey){
      const th=threads.find(x=>x.threadKey===currentThreadKey);
      list=th?th.items:[];
    }
  
    const kw = document.getElementById("searchInput").value.toLowerCase().trim();
    if(kw){
      list = list.filter(m=>(m.subject+m.body+m.from+m.to).toLowerCase().includes(kw));
    }
  
    // ================================
    // â‘  ìµœì´ˆ ì´ë©”ì¼ ì œëª© 1íšŒë§Œ í‘œì‹œ
    // ================================
    const viewInfo = document.getElementById("viewInfo");
    if(list.length > 0){
      viewInfo.innerHTML = `
        <div style="font-size:16px;font-weight:600;margin-bottom:10px;padding:6px 0;">
          ${esc(list[0].subject)}
        </div>
        <div style="font-size:12px;color:#555;">${currentView==="timeline"?"ì „ì²´ íƒ€ì„ë¼ì¸":"ìŠ¤ë ˆë“œ"}</div>
      `;
    } else {
      viewInfo.innerHTML = "";
    }
  
    const mc=document.getElementById("mailContainer");
    mc.innerHTML="";
  
    // ================================
    // ë©”ì¼ ì¹´ë“œ ë°˜ë³µ
    // ================================
    list.forEach((m,i)=>{
      const d=document.createElement("div");
      d.className="mail-card";
  
      // ì œëª© ì œê±° â€” ë‚ ì§œ + From/Toë§Œ í‘œì‹œ
      d.innerHTML=`
        <div class="mail-header">
          <div class="mail-meta">
            From: ${esc(m.from)}<br>
            To: ${esc(m.to)}
          </div>
          <div class="mail-date">${esc(fmtDate(m.dateObj))}</div>
        </div>
  
        <div class="mail-body-preview">
          ${esc(m.preview)} <span class="clickable" id="toggle_${i}">ë”ë³´ê¸°</span>
        </div>
  
        <div class="mail-body-full" id="full_${i}">${esc(m.body)}</div>
  
        <div style="margin-top:6px">
          <span class="pill">${esc(m.filename)}</span>
          <span class="pill">EML</span>
        </div>
      `;
  
      mc.appendChild(d);
  
      const toggle = document.getElementById(`toggle_${i}`);
      const full   = document.getElementById(`full_${i}`);
  
      toggle.onclick=()=>{
        const show = full.style.display==="block";
        full.style.display = show?"none":"block";
        toggle.textContent = show?"ë”ë³´ê¸°":"ì ‘ê¸°";
      };
    });
  }


  /* --------------------------
     ì¼€ì´ìŠ¤ ë¶ˆëŸ¬ì˜¤ê¸° / ìƒì„±
  -------------------------- */
  async function loadCases(){
    try{
      const idx = await ghGet("cases/index.json");
      if(!idx){
        casesMeta=[];caseData={};currentCaseId=null;
        renderCaseList();
        return;
      }
      casesMeta=idx;
      caseData={};
      currentCaseId=null;
      renderCaseList();
    }catch(e){alert("ì¼€ì´ìŠ¤ ëª©ë¡ ë¶ˆëŸ¬ì˜¤ê¸° ì‹¤íŒ¨: "+e.message);}
  }

  function renderCaseList(){
    const el=document.getElementById("caseList");
    el.innerHTML="";
    casesMeta.forEach(c=>{
      const div=document.createElement("div");
      div.className="case-item"+(c.id===currentCaseId?" active":"");
      div.textContent=c.name;
      div.onclick=()=>selectCase(c.id);
      el.appendChild(div);
    });
  }

  async function selectCase(id){
    currentCaseId=id;
    renderCaseList();
    try{
      const obj=await ghGet(`cases/${id}.json`);
      if(obj){
        caseData[id]=obj;
        allEmails=obj.emails||[];
        postProcess();
      }
    }catch(e){alert("ì¼€ì´ìŠ¤ ë¡œë”© ì‹¤íŒ¨ "+e.message);}
  }

  async function addCase(){
    const name=prompt("ì¼€ì´ìŠ¤ ì´ë¦„ì„ ì…ë ¥í•˜ì„¸ìš”:");
    if(!name) return;
    const id="case_"+Date.now();

    casesMeta.push({id,name});
    caseData[id]={id,name,emails:[]};
    currentCaseId=id;

    await ghPut("cases/index.json",casesMeta,"case index update");
    await ghPut(`cases/${id}.json`,caseData[id],"create case");

    renderCaseList();
  }

  /* --------------------------
     ì´ë²¤íŠ¸ ë°”ì¸ë”©
  -------------------------- */
  const fileInput   = document.getElementById("fileInput");
  const dropZone    = document.getElementById("dropZone");
  const searchInput = document.getElementById("searchInput");
  const btnTimeline = document.getElementById("btnTimeline");
  const btnThread   = document.getElementById("btnThread");

  document.getElementById("btnSaveGh").onclick=()=>{
    github.token = document.getElementById("ghToken").value.trim();
    localStorage.setItem("github_token",github.token);
    alert("GitHub í† í°ì„ ì €ì¥í–ˆìŠµë‹ˆë‹¤.");
  };
  document.getElementById("btnLoadCases").onclick=loadCases;
  document.getElementById("btnAddCase").onclick=addCase;

  btnTimeline.onclick=()=>{
    currentView="timeline";currentThreadKey=null;
    btnTimeline.classList.add("active");btnThread.classList.remove("active");
    renderView();
  };
  btnThread.onclick=()=>{
    currentView="thread";
    btnThread.classList.add("active");btnTimeline.classList.remove("active");
    renderView();
  };

  searchInput.oninput=renderView;
  document.getElementById("btnClearSearch").onclick=()=>{
    searchInput.value="";renderView();
  };

  fileInput.onchange=(e)=>handleFiles([...e.target.files]);

  window.ondragover=e=>{e.preventDefault();dropZone.classList.add("dragover");};
  window.ondragleave=()=>dropZone.classList.remove("dragover");
  window.ondrop=e=>{
    e.preventDefault();dropZone.classList.remove("dragover");
    handleFiles([...e.dataTransfer.files]);
  };

  // ì´ˆê¸° í† í° ë¡œë”©
  (function(){
    const t=localStorage.getItem("github_token");
    if(t){
      github.token=t;
      document.getElementById("ghToken").value=t;
    }
  })();
</script>

</body>
</html>
